<!DOCTYPE html><html><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, minimal-ui"><meta name="robots" content="none"><title>marlou knowledge base</title><link href="/github-markdown.d098492d.css" rel="stylesheet" media="all"><link href="/main.cb64a04a.css" rel="stylesheet" media="all"><link href="/github.51c27d45.css" rel="stylesheet"><script src="/docs.a0c71561.js"></script></head><body><article class="markdown-body"><h1 id="title-this-keyword"><code>this</code> keyword</h1> <h2 id="title-articles">articles</h2> <p><a href="https://toddmotto.com/understanding-the-this-keyword-in-javascriphtml">understanding-the-this-keyword-in-javascript : toddmotto.com</a></p> <p><a href="https://developer.mozilla.org/fr/docs/Web/JavaScript/Reference/Op%C3%A9rateurs/L_op%C3%A9rateur_thhtml">developer.mozilla.org</a></p> <p><a href="https://glebbahmutov.com/blog/test-closures/#mohtml">Tests, closures and arrow functions : glebbahmutov.com</a></p> <blockquote> <p><code>this</code> keyword in JavaScript will burn you one day. Then it will burn you again and again and again. If Dante Alighieri were alive today, he would put writing object-oriented JavaScript among one of the first levels of Hell for sure.</p> </blockquote> <p><a href="https://github.com/Microsoft/TypeScript/wiki/%27this%27-in-TypeScrihtml">‘this’ in TypeScript - TypeScript/wiki</a></p> <h2 id="title-code-demo">code demo</h2> <p>Every new <code>function</code> defined its own <code>this</code> value :</p> <pre><code class="lang-javascript">function Person() {
  // The Person() constructor defines `this` as an instance of itself.
  this.age = 0;
  this.printAge = function () {
    console.log(this.age);
  };

  setInterval(function growUp() {
    // In non-strict mode, the growUp() function defines `this` 
    // as the global object, which is different from the `this`
    // defined by the Person() constructor.
    this.age++;
  }, 1000);
}

var p = new Person();
p.printAge(); // 0</code></pre> <p>In <strong>ECMAScript 3/5</strong>, the <code>this</code> issue was fixable by assigning the value in <code>this</code> to a variable that could be closed over.</p> <pre><code class="lang-javascript">function Person() {
  var that = this;
  that.age = 0;
  that.printAge = function () {
    console.log(this.age);
  };


  setInterval(function growUp() {
    // The callback refers to the `that` variable of which
    // the value is the expected object.
    that.age++;
  }, 1000);
}

var p = new Person();
p.printAge(); // 0 then ++ each second</code></pre> <p>In <strong>ECMAScript 6</strong>, an arrow function does not create its own <code>this</code>, the <code>this</code> value of the enclosing execution context is used.</p> <pre><code class="lang-javascript">function Person(){
  this.age = 0;
  this.sayAge = function () {
    console.log(this.age);
  };

  setInterval(() =&gt; {
    this.age++; // |this| properly refers to the person object
  }, 1000);
}

var p = new Person();
p.sayAge(); // 0 then ++ each second</code></pre> </article></body></html>
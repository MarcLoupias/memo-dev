<!DOCTYPE html><html><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, minimal-ui"><meta name="robots" content="none"><title>marlou knowledge base</title><link href="/github-markdown.7d1fca7c.css" rel="stylesheet" media="all"><link href="/main.4b9cca7f.css" rel="stylesheet" media="all"><link href="/github.8c766760.css" rel="stylesheet"><script src="/docs.39594acf.js"></script></head><body><article class="markdown-body"><h1 id="title-angular---migration-from-angularjs">Angular - Migration from AngularJS</h1>
<p><a href="https://angular.io/guide/upgrade">Upgrade guide ng2 doc</a></p>
<p><a href="https://www.codeproject.com/Articles/1121384/AngularJS-Migration-Guide">AngularJS 2.0 Migration Guide : codeproject.com</a></p>
<blockquote>
<p>2016/08/31</p>
<p><strong>Preparation</strong></p>
<ul>
<li>Follow the John Papa’s Styleguide for Angular 1 development</li>
<li>Update to the latest version of Angular 1</li>
<li>All new development using components</li>
<li>Switch controllers to components (component directives)</li>
<li>Remove incompatible features (specific to Angular 2) from directives</li>
<li>Implement manual bootstrapping (No more ng-app)</li>
</ul>
<p><strong>Upgrade</strong></p>
<ul>
<li>Add TypeScript transpilation and build</li>
<li>Start using ES6 or Javascript 2015</li>
<li>Switch controllers and services to ES6 Classes</li>
<li>Add Angular 2.0 to your project</li>
<li>Migrate one piece at a time</li>
</ul>
</blockquote>
<p><a href="http://maxlab.fr/javascript/migrer-de-angularjs-1-x-vers-angularjs-2-0-pratique/#foot_loc_1403_1">Préparer la migration de AngularJS 1.x vers AngularJS 2.0 : maxlab.fr</a></p>
<blockquote>
<p>Eviter l’usage de <code>$scope</code> et utiliser la syntaxe <code>ControllerAs</code>.</p>
<p>Supprimer le <code>$scope</code>, c’est supprimer <code>$watch</code> <code>$apply</code> <code>$timeout</code> .. des notions qui compliquent l’apprentissage du<br>framework et sont souvent à l’origine de <a href="http://www.bennadel.com/blog/2605-scope-evalasync-vs-timeout-in-angularjs.htm">hacks</a>.</p>
<p>Au lieu de créer un controleur et d’utiliser <code>ng-controller</code>, préférez l’usage d’une directive.</p>
<p>Tirer profit des fonctionnalités d’ECMAscript 6/2015</p>
<ul>
<li>Les <a href="https://developer.mozilla.org/fr/docs/Web/JavaScript/Reference/Instructions/import">modules</a> :<br>pour appliquer le paragraphe précédent sur le découplage</li>
<li>Les <a href="https://developer.mozilla.org/fr/docs/Web/JavaScript/Reference/Fonctions/Fonctions_fl%C3%A9ch%C3%A9es">arrow functions</a> :<br>pour simplifier les retours issues de promises, l’utilisation des fonctions sur les tableaux et le binding du <code>this</code></li>
<li>La <a href="http://ariya.ofilabs.com/2013/02/es6-and-object-literal-property-value-shorthand.html">notation objet simplifiée</a><br>et la <a href="https://developer.mozilla.org/fr/docs/Web/JavaScript/Reference/Op%C3%A9rateurs/Affecter_par_d%C3%A9composition">décomposition</a> :<br>pour réduire le code et augmenter la lisibilité</li>
<li>Les classes : pour coller à la syntaxe d’Angular 2 et éventuellement utiliser les <a href="https://github.com/wycats/javascript-decorators">décorateurs d’ES7</a></li>
</ul>
<p>Services : Dans Angular 2, les services sont de simples classes, il est préférable de n’utiliser que <code>angular.service</code><br>dans Angular 1</p>
</blockquote>
<p><a href="https://www.inrhythm.com/upgrading-angular-1-to-react-angular-2/">Preparing your Angular 1 codebase to upgrade to React or Angular 2 - www.inrhythm.com - 20170424</a></p>
<blockquote>
<ul>
<li><p>Step 1: Integrate Webpack into your build process</p>
<ul>
<li>use index.js files in each dir/subdir to build a tree of files (all files : js, css and html)</li>
<li>drop gulp in favor of Webpack</li>
</ul>
</li>
<li><p>Step 2: Embrace ES6 modules, upgrade Angular services and controllers to ES6 classes</p>
<ul>
<li>replace global objects through IIFE with ES6 imports</li>
<li>refactor old functions definitions for components and services with classes</li>
</ul>
</li>
<li><p>Step 3: Abstract away the Angular module system and decouple your source code from the framework</p>
<ul>
<li>replace angular builtin helpers functions with lodash functions</li>
<li>use the ui-router pattern (a single ngModule for all the app, and use the regular ES6 modules)</li>
</ul>
</li>
</ul>
</blockquote>
<p><strong>RETEX Step 1</strong></p>
<p>Fonctionne très bien mais pas facile :</p>
<ul>
<li>attention à l’ordre des <code>import</code> dans les fichiers <code>index.js</code>, placer les déclarations de modules en premier dans chaque fichier</li>
<li>si usage de Bootstrap, il suppose la présence de l’objet <code>jQuery</code> sur l’objet <code>window</code>, il convient donc de l’ajouter :</li>
</ul>
<pre><code class="lang-javascript">    // webpack conf

    plugins: [

        // ...

        new webpack.ProvidePlugin({
            $: &#39;jquery&#39;,
            jQuery: &#39;jquery&#39;,
            &#39;window.jQuery&#39;: &#39;jquery&#39;
        })
    ]</code></pre>
<ul>
<li>il est possible que certaines dépendances soient chargées plusieurs fois selon comment elles sont organisées. Par exemple d’avoir ce message de AngularJS <code>WARNING: Tried to load angular more than once.</code>. Ca augmente la taille du bundle mais comme c’est temporaire on peut passer outre le temps de tout passer en modules ES6.</li>
<li>problème avec les variables globales (par ex fichier de config). Dans un premier temps, coller ces variables dans l’objet global <code>window</code> (cf <a href="https://stackoverflow.com/questions/37656592/define-global-variable-with-webpack">https://stackoverflow.com/questions/37656592/define-global-variable-with-webpack</a>). Attention à l’ordre des imports comme pour les modules AngularJS.</li>
<li>problème avec les dépendances importées via l’IIFE en tant que variables globales. Passer directement par un import classique depuis le source concerné en plus de l’IIFE. Par ex : <code>import Fuse from &#39;../../../../node_modules/fuse.js/dist/fuse.min&#39;;</code> à ajouter en tête de fichier devant l’IIFE qui n’est pas touchée.</li>
<li>problème avec les templates des composants : <a href="https://stackoverflow.com/questions/33300289/how-to-use-webpack-with-angular-templatecache">https://stackoverflow.com/questions/33300289/how-to-use-webpack-with-angular-templatecache</a>. La solution la plus simple est de ne pas importer les html via les <code>index.js</code> mais direct via les composants en faisant un <code>require</code> du fichier html sur la props <code>template</code> plutôt que via <code>templateUrl</code>.</li>
<li>problème avec les css. Attention depuis le browser les urls des css sont résolvées avec le chemin relatif serveur de la css. Par exemple, si sur le serveur web j’ai <code>/assets/css/app.css</code> et que dans cette css j’ai une instruction <code>url()</code> qui pointe sur <code>/assets/fonts/toto.woff</code> par exemple, lorsque le call sera effectué dans le browser ça ira chercher sur <code>/assets/css/assets/fonts/toto.woff</code>. Il convient donc de placer les css à la racine du serveur web pour éviter ce problème.</li>
<li>problème dans certains templates : Il faut être très strict sur la présentation de caractères spéciaux dans les templates, il ne faut par exemple aucun opérateur logique webpack aime pas !</li>
</ul>
<p><strong>RETEX Step 2</strong></p>
<p>Dans les grandes lignes :</p>
<ul>
<li>utiliser les <code>import</code>/<code>export</code> ES6</li>
<li>supprimer toutes les IIFE</li>
<li>passer du style-guide de John Papa qui est calibré sur AngularJS avec ES5 à <a href="https://github.com/toddmotto/angularjs-styleguide">celui de Todd Motto</a> qui est calibré pour ES2015.</li>
</ul>
<p>concrètement :</p>
<ul>
<li>supprimer les IIFE, exporter l’objet/fonction de description du component/filter/service/directive</li>
<li>renommer la fonction de déclaration de <code>blablaService</code> en <code>blabla</code>, exporter en nommant le type de composant (Component, Filter, Service, Directive).</li>
</ul>
<p>Par exemple pour un composant référencé <code>&#39;headerView&#39;</code> dans l’injecteur ayant un contrôleur <code>HeaderViewController</code> :</p>
<p>Avant on a </p>
<pre><code class="lang-javascript">// header-view.component.js
    angular
        .module(&#39;app.header&#39;)
        .component(&#39;headerView&#39;, {
            template: require(&#39;./header-view.html&#39;),
            controller: HeaderViewController
        });</code></pre>
<p>Après on a :</p>
<pre><code class="lang-javascript">// header-view.component.js
export const HeaderViewComponent = {
    template: require(&#39;./header-view.html&#39;),
    controller: HeaderViewController
};

// puis la déclaration des injections de HeaderViewController
HeaderViewController.$inject = [/* ... */];

// puis l&#39;implémentation du ctrl
function HeaderViewController(/* ... */) {
    var ctrl = this;
    // ...</code></pre>
<ul>
<li>importer dans la déclaration du module afférant</li>
</ul>
<p>Dans le fichier <code>*.module.js</code> correspondant c’est là qu’on va désormais déclarer les composants à l’injecteur.</p>
<pre><code class="lang-javascript">// header.module.js
import angular from &#39;angular&#39;;
// ...
import {HeaderViewComponent} from &#39;./header-view.component&#39;;

const header = angular.module(&#39;app.header&#39;, []);
// ...
header.component(&#39;headerView&#39;, HeaderViewComponent);

// on exporte le module pour l&#39;importer à son tour dans le module de niveau supérieur
export const HeaderModule = header;

// Attention le module qui importe ce module doit set le nom en dépendant et pas le module lui même :

// app.module.js
import angular from &#39;angular&#39;;
import {HeaderModule} from &#39;./layout/header/header.module&#39;;
//...
const app = angular.module(&#39;app&#39;, [HeaderModule.name]);</code></pre>
<ul>
<li>supprimer les fichiers <code>index.js</code> dont les <code>import</code> font doublons</li>
<li>garder les <code>index.js</code> pour les dépendances et le point d’entrée de l’appli</li>
<li>reconfigurer ESLint pour prendre en charge ES2015 et les modules :<pre><code class="lang-javascript">  &quot;parserOptions&quot;: {
      &quot;ecmaVersion&quot;: 6,
      &quot;sourceType&quot;: &quot;module&quot;
  }</code></pre>
</li>
<li>après cette migration, <strong>Karma n’est plus capable d’exécuter les TU out-of-the-box</strong>. Les remettre d’aplomb n’est pas utile puisqu’il n’y aura aucun dev et que Cypress permet de tester la non-régression (suppose d’avoir des tests d’UI suffisamment fiables, Cypress est parfait pour ça !).</li>
<li>refacto les composants / services / controller / etc … en classes.</li>
</ul>
<p>composants :</p>
<p>La fonction déclarant le controller devient une classe.<br>On ajoute un constructeur à cette classe pour réaliser les injections de dépendances :</p>
<pre><code class="lang-javascript">    constructor(logger, headerMenuConfigObjectService, headerService) {
        this.logger = logger;
        this.headerMenuConfigObjectService = headerMenuConfigObjectService;
        this.headerService = headerService;
    }</code></pre>
<p>On binde les services à l’instance. Le <code>var ctrl = this;</code> disparait.</p>
<p>Les fonctions implémentants les events hooks :</p>
<pre><code class="lang-javascript">    ctrl.$onInit = function init() {
        logger.info(&#39;app.header.HeaderViewController.$onInit()&#39;, &#39;start&#39;);
        ctrl.grandMenu = headerMenuConfigObjectService.getMenu();
        ctrl.stats = headerService.data;
        ctrl.clickRefreshData = headerService.clickRefreshData;
        logger.info(&#39;app.header.HeaderViewController.$onInit() ctrl.grandMenu = &#39;, ctrl.grandMenu);
    };</code></pre>
<p>deviennent des fonctions de la classe :</p>
<pre><code class="lang-javascript">    $onInit() {
        this.logger.info(&#39;app.header.HeaderView.$onInit()&#39;, &#39;start&#39;);
        //this.grandMenu = this.headerMenuConfigObjectService.getMenu(); // inutile puisque headerMenuConfigObjectService est bind au moment de son injection
        this.stats = this.headerService.data;
        //this.clickRefreshData = this.headerService.clickRefreshData; // inutile puisque headerService est bind au moment de son injection
        this.logger.info(&#39;app.header.HeaderView.$onInit() ctrl.grandMenu = &#39;, this.grandMenu);
    }</code></pre>
<p>en l’absence de ngAnnotate, la déclaration des dépendances à injecter doit être conservée :</p>
<pre><code class="lang-javascript">HeaderView.$inject = [
    &#39;logger&#39;, &#39;headerMenuConfigObjectService&#39;, &#39;headerService&#39;
];</code></pre>
<p>On se retrouve avec 3 blocs : </p>
<ul>
<li>l’export de la déclaration du composant (un litteral) qui deviendra un decorator en Angular.</li>
<li>la classe implémentant le comportement du composant (l’ancien controller)</li>
<li>la déclaration explicite des dépendances à injecter</li>
</ul>
<p>Attention la classe doit être impérativement déclarée en premier. Il faut donc déplacer les blocs pour avoir la classe en premier, ensuite les injections et enfin l’export.</p>
<p>Attention il faut transformer les fonctions anonymes des résolutions de promesses dans les composants par des arrows functions (à cause du <code>this</code>)</p>
<p>Attention avec les services, lorsqu’on a défini l’implémentation de higher order function (<code>reduce</code>, <code>map</code>, <code>filter</code>) dans une fonction du service/directive et qu’on la passait telle quelle (la définition de la fonction sans l’exécuter), maintenant que ces fonctions sont des méthodes de fonctions il est nécessaire d’avoir une exécution.</p>
<p>On ne peut plus faire :</p>
<pre><code class="lang-javascript">selectedTagList.map(this.mapTagListToTagListName);</code></pre>
<p>où <code>mapTagListToTagListName</code> serait une méthode de la même classe telle que :</p>
<pre><code class="lang-javascript">    mapTagListToTagListName(item) {
        return item.text;
    }</code></pre>
<p>on doit exécuter la méthode :</p>
<pre><code class="lang-javascript">selectedTagList.map(this.mapTagListToTagListName())</code></pre>
<p>et donc retourner la fonction implémentant la <code>map</code></p>
<pre><code class="lang-javascript">    mapTagListToTagListName() {
        return (item) =&gt; {
            return item.text;
        }
    }</code></pre>
<p><a href="http://blogtech.soprasteria.com/2017/05/24/quelques-grands-principes-pour-aller-vers-angular-2-x-en-venant-dangular-1-4/">Quelques grands principes pour aller vers Angular 2.x en venant d’Angular 1.4 ? : blogtech.soprasteria.com</a></p>
<blockquote>
<p>Très détaillé avec contextualisation + plein de bons liens en fin d’article</p>
</blockquote>
<p><a href="https://blog.xebia.fr/2016/03/01/webpack-es6-es2015-babel-6-pour-modulariser-son-application-angularjs/">Webpack, ES6 (ES2015) &amp; Babel 6 pour modulariser son application AngularJS - blog.xebia.fr - 20160301</a></p>
<blockquote>
<p>montre un exemple possible d’état intermédiaire (ES2015 + Babel + Webpack) lors de la migration quand on part d’un AngularJS legacy (par ex ng1.4 + ES5 + grunt/gulp).</p>
</blockquote>
<p><a href="https://github.com/Gillespie59/angular2-migration-sample">Gillespie59/angular2-migration-sample : github.com</a></p>
<blockquote>
<p>a short example</p>
</blockquote>
<p><a href="https://github.com/ngmigrate/ngmigrate.github.io">ngmigrate/ngmigrate.github.io : github.com</a></p>
<blockquote>
<p>source code of the Todd Motto migration guide <a href="http://developer.telerik.com/angular-2-migration-guide/">ng-migrate</a></p>
</blockquote>
<p><a href="https://github.com/ngParty/ng1-migration-workshop">ngParty/ng1-migration-workshop : github.com</a></p>
<blockquote>
<p>migration example app from angular 1.x ES5 to Typescript and ngMetadata </p>
</blockquote>
<p><a href="http://blog.rangle.io/upgrade-your-application-to-angular-2-with-ng-upgrade/">Upgrading Your Application to Angular 2 with ng-upgrade : blog.rangle.io</a></p>
<p><a href="https://blog.thoughtram.io/angular/2015/10/24/upgrading-apps-to-angular-2-using-ngupgrade.html">Upgrading Angular apps using ngUpgrade - Pascal Precht - 20161218</a></p>
<p><a href="https://blog.nrwl.io/ngupgrade-in-depth-436a52298a00">NgUpgrade in Depth - Victor Savkin - 20170512</a></p>
<h2 id="title-migration-des-watch">migration des <code>$watch</code></h2>
<ul>
<li>soit on a un ng-model auquel cas il suffit d’ajouter un ng-change</li>
<li>soit on a besoin de AngularJS 1.5 et d’utiliser le life cycle event <code>$onChanges</code> des composants</li>
</ul>
<p>L’idée avec les life cycles event c’est de remplacer le dirty checking d’origine placé sur tout l’arbre des scopes par un cycle de vie centré composant par composant.</p>
<h2 id="title-migration-ui-router">migration ui-router</h2>
<p>To upgrade ui-router 0.4.x to 1.0.x, we need to use a bundler and modules.</p>
<p>Check full example at <a href="https://github.com/ui-router/sample-app-angularjs">sample-app-angularjs - github.com/ui-router</a></p>
<p>If you don’t want to migrate from IIFE to ES6 modules and a bundlers (you want to upgrade ui-router first before the bundlers and ES6 modules), you can import a mono-bundle backward compatible, cf <a href="https://ui-router.github.io/blog/uirouter-for-angularjs-umd-bundles/"><br>Uirouter For Angularjs Umd Bundles
</a> post.</p>
<p>Using <code>&lt;script src=&quot;../node_modules/@uirouter/angularjs/release/angular-ui-router.min.js&quot;&gt;&lt;/script&gt;</code> works well in an ES5 / AngularJS 1.6+ code base with <code>@uirouter/angularjs@1.0.17</code>.</p>
<p>The main breaking change is the removal of <code>$rootScope</code> events replaced by <code>$transitions</code> services hooks.</p>
<p>The <code>$stateParams</code> service becomes <strong>deprecated</strong>. The best way to deal with it <a href="https://github.com/angular-ui/ui-router/issues/3110#issuecomment-315855728">is explained here</a> :</p>
<p>Inject <code>$uiRouterGlobals</code> and use its attribute <code>params [Object]</code> like this: <code>$uiRouterGlobals.params.myParam</code></p>
</article></body></html>
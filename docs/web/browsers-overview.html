<!DOCTYPE html><html><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, minimal-ui"><meta name="robots" content="none"><title>marlou knowledge base</title><link href="/github-markdown.7d1fca7c.css" rel="stylesheet" media="all"><link href="/main.4b9cca7f.css" rel="stylesheet" media="all"><link href="/github.8c766760.css" rel="stylesheet"><script src="/docs.a092d0a1.js"></script></head><body><article class="markdown-body"><h1 id="title-browsers-overview">browsers overview</h1>
<h2 id="title-moteurs-de-rendus">moteurs de rendus</h2>
<p>cf <a href="https://www.youtube.com/watch?v=ceMLuRBn--M">The third browser war is over and it’s a bloodshed - Daniel Glazman - WEB2DAY 2016</a></p>
<table>
<thead>
<tr>
<th>-</th>
<th>modern</th>
<th>standards</th>
<th>cross platform</th>
<th>speed</th>
<th>author</th>
</tr>
</thead>
<tbody><tr>
<td>Gecko</td>
<td>OK</td>
<td>OK</td>
<td>OK</td>
<td>OK</td>
<td><a href="https://www.mozilla.org/fr/foundation/">Mozilla Foundation</a></td>
</tr>
<tr>
<td>WebKit</td>
<td>OK</td>
<td>OK</td>
<td>OK</td>
<td>OK</td>
<td><a href="https://webkit.org/">Apple</a></td>
</tr>
<tr>
<td>Blink</td>
<td>OK</td>
<td>OK</td>
<td>OK</td>
<td>OK</td>
<td><a href="http://www.chromium.org/blink">chromium (Google)</a></td>
</tr>
<tr>
<td>Edge</td>
<td>OK</td>
<td>OK</td>
<td>KO</td>
<td>OK</td>
<td><a href="https://en.wikipedia.org/wiki/EdgeHTML">EdgeHTML (Microsoft)</a></td>
</tr>
<tr>
<td>Servo</td>
<td>OK</td>
<td>OK</td>
<td>OK</td>
<td>OK</td>
<td><a href="https://servo.org/">servo.org (Mozilla Foundation)</a></td>
</tr>
</tbody></table>
<p><a href="https://fr.wikipedia.org/wiki/Trident_(moteur_de_rendu)">Trident moteur de IE4 à IE11</a> : stoppé.</p>
<p><a href="https://github.com/servo/servo">servo/servo - github.com</a></p>
<p>Servo écrit en Rust est le petit nouveau. MultiThreadé et layout parallèle. Ultra performant. Va probablement beaucoup changer la donne sur mobile.<br>Meilleure vitesse mais surtout meilleure conso. (d’où la collaboration Mozilla / Samsung).</p>
<p>Opera a abandonné Presto et est passé sur Blink</p>
<p>Un process par tab, chaque process multithreadé + layout parallèle = gains x30 à x50.</p>
<p><a href="https://www.developpez.com/actu/236606/C-est-officiel-Microsoft-Edge-sera-desormais-base-sur-Chromium-et-enfin-disponible-sur-Windows-7-Windows-8-et-d-autres-plateformes-comme-macOS/">C’est officiel, Microsoft Edge sera désormais basé sur Chromium</a>)</p>
<blockquote>
<p>Cela signifie que Microsoft va remplacer son moteur de rendu EdgeHTML et son moteur JavaScript Chackra par Blink et V8 de Chromium.</p>
<p>Microsoft prévoit encore de publier le nouveau Microsoft Edge sur toutes les versions prises en charge de Windows (c’est-à-dire Windows 7 et Windows 8), mais sans se limiter à son OS. </p>
<p>Le passage à Chromium prendra environ un an, selon Microsoft, et une préversion sera prête début 2019.</p>
</blockquote>
<h2 id="title-browsers-bug-trackers">browsers bug trackers</h2>
<p><a href="http://dev.chromium.org/for-testers/bug-reporting-guidelines">dev.chromium.org</a></p>
<p><a href="https://bugzilla.mozilla.org/">bugzilla.mozilla.org</a></p>
<h2 id="title-the-browsers-main-functionality">The browser’s main functionality</h2>
<p>The main function of a browser is to present the web resource you choose, by requesting it from the server and displaying it in the browser window. The resource is usually an HTML document, but may also be a PDF, image, or some other type of content. The location of the resource is specified by the user using a URI (Uniform Resource Identifier).</p>
<p>The way the browser interprets and displays HTML files is specified in the HTML and CSS specifications. These specifications are maintained by the W3C (World Wide Web Consortium) organization, which is the standards organization for the web. For years browsers conformed to only a part of the specifications and developed their own extensions. That caused serious compatibility issues for web authors. Today most of the browsers more or less conform to the specifications.</p>
<p>Browser user interfaces have a lot in common with each other. Among the common user interface elements are:</p>
<ul>
<li>Address bar for inserting a URI</li>
<li>Back and forward buttons</li>
<li>Bookmarking options</li>
<li>Refresh and stop buttons for refreshing or stopping the loading of current documents</li>
<li>Home button that takes you to your home page</li>
</ul>
<h2 id="title-the-browsers-high-level-structure">The browser’s high level structure</h2>
<ol>
<li>The user interface: this includes the address bar, back/forward button, bookmarking menu, etc. Every part of the browser display except the window where you see the requested page.</li>
<li>The browser engine: marshals actions between the UI and the rendering engine.</li>
<li>The rendering engine : responsible for displaying requested content. For example if the requested content is HTML, the rendering engine parses HTML and CSS, and displays the parsed content on the screen.</li>
<li>Networking: for network calls such as HTTP requests, using different implementations for different platform behind a platform-independent interface.</li>
<li>UI backend: used for drawing basic widgets like combo boxes and windows. This backend exposes a generic interface that is not platform specific. Underneath it uses operating system user interface methods.</li>
<li>JavaScript interpreter. Used to parse and execute JavaScript code.</li>
<li>Data storage. This is a persistence layer. The browser may need to save all sorts of data locally, such as cookies. Browsers also support storage mechanisms such as localStorage, IndexedDB, WebSQL and FileSystem.</li>
</ol>
<p><img src="https://www.html5rocks.com/en/tutorials/internals/howbrowserswork/layers.png" alt=""></p>
<h2 id="title-how-do-browsers-render-a-web-page">How do browsers render a web page</h2>
<ol>
<li>The DOM (Document Object Model) is formed from the HTML that is received from a server.</li>
<li>Styles are loaded and parsed, forming the CSSOM (CSS Object Model).</li>
<li>On top of DOM and CSSOM, a rendering tree is created, which is a set of objects to be rendered (Webkit calls each of those a “renderer” or “render object”, while in Gecko it’s a “frame”). Render tree reflects the DOM structure except for invisible elements (like the <head>tag or elements that have display:none; set). Each text string is represented in the rendering tree as a separate renderer. Each of the rendering objects contains its corresponding DOM object (or a text block) plus the calculated styles. In other words, the render tree describes the visual representation of a DOM.</head></li>
<li>For each render tree element, its coordinates are calculated, which is called “layout”. Browsers use a flow method which only required one pass to layout all the elements (tables require more than one pass).</li>
<li>Finally, this gets actually displayed in a browser window, a process called “painting”.</li>
</ol>
<p><img src="http://www.phpied.com/files/reflow/render.png" alt=""></p>
<p>When users interact with a page, or scripts modify it, some of the aforementioned operations have to be repeated, as the underlying page structure changes.</p>
<h2 id="title-html-parsing">HTML Parsing</h2>
<p>HTML cannot be parsed using the regular top down or bottom up parsers.<br>The reasons are:</p>
<ol>
<li>The forgiving nature of the language: the fact that browsers have traditional error tolerance to support well known cases of invalid HTML.</li>
<li>The parsing process is reentrant. For other languages, the source doesn’t change during parsing, but in HTML, dynamic code (such as script elements containing document.write() calls) can add extra tokens, so the parsing process actually modifies the input.</li>
<li>Speculative parsing: for scripts, css, images we will forward.</li>
</ol>
<p>The algorithm consists of two stages: tokenization and tree construction.<br>Tokenization is the lexical analysis, parsing the input into tokens. Among HTML tokens are start tags, end tags, attribute names and attribute values.<br>The tokenizer recognizes the token, gives it to the tree constructor, and consumes the next character for recognizing the next token, and so on until the end of the input.</p>
<h2 id="title-css-parsing">CSS Parsing</h2>
<p>It just creates the CSSOM.</p>
<h2 id="title-render--frame-tree">Render / Frame Tree</h2>
<p>While the DOM tree is being constructed, the browser constructs another tree, the render tree. This tree is of visual elements in the order in which they will be displayed. It is the visual representation of the document. The purpose of this tree is to enable painting the contents in their correct order.</p>
<p>Firefox calls the elements in the render tree “frames”. WebKit uses the term renderer or render object.<br>A renderer knows how to lay out and paint itself and its children.<br>WebKit’s RenderObject class, the base class of the renderers, has the following definition:</p>
<pre><code class="lang-c">class RenderObject{
  virtual void layout();
  virtual void paint(PaintInfo);
  virtual void rect repaintRect();
  Node* node;  //the DOM node
  RenderStyle* style;  // the computed style
  RenderLayer* containgLayer; //the containing z-index layer
}</code></pre>
<p>Each renderer represents a rectangular area usually corresponding to a node’s CSS box, as described by the CSS2 spec. It includes geometric information like width, height and position.<br>The box type is affected by the “display” value of the style attribute that is relevant to the node (see the style computation section). Here is WebKit code for deciding what type of renderer should be created for a DOM node, according to the display attribute:</p>
<pre><code class="lang-c">RenderObject* RenderObject::createObject(Node* node, RenderStyle* style)
{
    Document* doc = node-&gt;document();
    RenderArena* arena = doc-&gt;renderArena();
    ...
    RenderObject* o = 0;

    switch (style-&gt;display()) {
        case NONE:
            break;
        case INLINE:
            o = new (arena) RenderInline(node);
            break;
        case BLOCK:
            o = new (arena) RenderBlock(node);
            break;
        case INLINE_BLOCK:
            o = new (arena) RenderBlock(node);
            break;
        case LIST_ITEM:
            o = new (arena) RenderListItem(node);
            break;
       ...
    }

    return o;
}</code></pre>
<h2 id="title-layout">Layout</h2>
<p>When the renderer is created and added to the tree, it does not have a position and size. Calculating these values is called layout or reflow.</p>
<p>HTML uses a flow based layout model, meaning that most of the time it is possible to compute the geometry in a single pass. Elements later <code>in the flow&#39;&#39; typically do not affect the geometry of elements that are earlier</code>in the flow’’, so layout can proceed left-to-right, top-to-bottom through the document. There are exceptions: for example, HTML tables may require more than one pass.</p>
<p>The coordinate system is relative to the root frame. Top and left coordinates are used.</p>
<p>Layout is a recursive process. It begins at the root renderer, which corresponds to the <html>element of the HTML document. Layout continues recursively through some or all of the frame hierarchy, computing geometric information for each renderer that requires it.</html></p>
<p>The position of the root renderer is 0,0 and its dimensions are the viewport–the visible part of the browser window.<br>All renderers have a “layout” or “reflow” method, each renderer invokes the layout method of its children that need layout.</p>
<h3 id="title-dirty-bit-system">Dirty bit system</h3>
<p>In order not to do a full layout for every small change, browsers use a “dirty bit” system. A renderer that is changed or added marks itself and its children as “dirty”: needing layout.</p>
<p>There are two flags: “dirty”, and “children are dirty” which means that although the renderer itself may be OK, it has at least one child that needs a layout.</p>
<h3 id="title-the-layout-algorithm">The layout algorithm</h3>
<ol>
<li>Parent renderer determines its own width.</li>
<li>Parent goes over children and:<ol>
<li>Place the child renderer (sets its x and y).</li>
<li>Calls child layout if needed–they are dirty or we are in a global layout, or for some other reason–which calculates the child’s height.</li>
</ol>
</li>
<li>Parent uses children’s accumulative heights and the heights of margins and padding to set its own height–this will be used by the parent renderer’s parent.</li>
<li>Sets its dirty bit to false.</li>
</ol>
<h2 id="title-paint">Paint</h2>
<p>In the painting stage, the render tree is traversed and the renderer’s “paint()” method is called to display content on the screen. Painting uses the UI infrastructure component.</p>
<h2 id="title-repaint">Repaint</h2>
<p>When changing element styles which don’t affect the element’s position on a page (such as background-color, border-color, visibility), the browser just repaints the element again with the new styles applied (that means a “repaint” or “restyle” is happening).</p>
<h2 id="title-reflow">Reflow</h2>
<p>When the changes affect document contents or structure, or element position, a reflow (or relayout) happens. These changes are usually triggered by:</p>
<ul>
<li>DOM manipulation (element addition, deletion, altering, or changing element order);</li>
<li>Contents changes, including text changes in form fields;</li>
<li>Calculation or altering of CSS properties;</li>
<li>Adding or removing style sheets;</li>
<li>Changing the “class” attribute;</li>
<li>Browser window manipulation (resizing, scrolling);</li>
<li>Pseudo-class activation (:hover).</li>
</ul>
<h3 id="title-how-browsers-optimize-rendering">How browsers optimize rendering</h3>
<p>Browsers are doing their best to restrict repaint/reflow to the area that covers the changed elements only. For example, a size change in an absolute/fixed positioned element only affects the element itself and its descendants, whereas a similar change in a statically positioned element triggers reflow for all the subsequent elements.</p>
<p>Another optimization technique is that while running pieces of JavaScript code, browsers cache the changes, and apply them in a single pass after the code was run. For example, this piece of code will only trigger one reflow and repaint:</p>
<pre><code class="lang-javascript">// only 1 reflow and repaint will actually happen
var $body = $(&#39;body&#39;);
$body.css(&#39;padding&#39;, &#39;1px&#39;); // reflow, repaint
$body.css(&#39;color&#39;, &#39;red&#39;); // repaint
$body.css(&#39;margin&#39;, &#39;2px&#39;); // reflow, repaint</code></pre>
<p>However, as mentioned above, accessing an element property triggers a forced reflow. This will happen if we add an extra line that reads an element property to the previous block:</p>
<pre><code class="lang-javascript">var $body = $(&#39;body&#39;);
$body.css(&#39;padding&#39;, &#39;1px&#39;);
$body.css(&#39;padding&#39;); // reading a property, a forced reflow
$body.css(&#39;color&#39;, &#39;red&#39;);
$body.css(&#39;margin&#39;, &#39;2px&#39;);</code></pre>
<p>As a result, we get 2 reflows instead of one. Because of this, you should group reading element properties together to optimize performance (see a more detailed example on JSBin).</p>
<p>There are situations when you have to trigger a forced reflow. Example: we have to apply the same property (“margin-left” for example) to the same element twice. Initially, it should be set to 100px without animation, and then it has to be animated with transition to a value of 50px. You can study this example on JSBin right now, but I’ll describe it here in more detail.</p>
<p>We start by creating a CSS class with a transition:</p>
<pre><code class="lang-css">.has-transition {
   -webkit-transition: margin-left 1s ease-out;
      -moz-transition: margin-left 1s ease-out;
        -o-transition: margin-left 1s ease-out;
           transition: margin-left 1s ease-out;
}</code></pre>
<p>Then proceed with the implementation:</p>
<pre><code class="lang-javascript">// our element that has a &quot;has-transition&quot; class by default
var $targetElem = $(&#39;#targetElemId&#39;);

// remove the transition class
$targetElem.removeClass(&#39;has-transition&#39;);

// change the property expecting the transition to be off, as the class is not there
// anymore
$targetElem.css(&#39;margin-left&#39;, 100);

// put the transition class back
$targetElem.addClass(&#39;has-transition&#39;);

// change the property
$targetElem.css(&#39;margin-left&#39;, 50);</code></pre>
<p>This implementation, however, does not work as expected. The changes are cached and applied only at the end of the code block. What we need is a forced reflow, which we can achieve by making the following changes:</p>
<pre><code class="lang-javascript">// remove the transition class
$(this).removeClass(&#39;has-transition&#39;);

// change the property
$(this).css(&#39;margin-left&#39;, 100);

// trigger a forced reflow, so that changes in a class/property get applied immediately
$(this)[0].offsetHeight; // an example, other properties would work, too

// put the transition class back
$(this).addClass(&#39;has-transition&#39;);

// change the property
$(this).css(&#39;margin-left&#39;, 50);</code></pre>
<p>Now this works as expected.</p>
<h2 id="title-practical-advice-on-optimization">Practical advice on optimization</h2>
<p>Summarizing the available information, I could recommend the following:</p>
<ul>
<li>Create valid HTML and CSS</li>
<li>Do not forget to specify the document encoding</li>
<li>Styles should be included into <head></head></li>
<li>Scripts appended to the end of the <body> tag. Think about async and defer attribute.</body></li>
<li>Try to simplify and optimize CSS selectors (this optimization is almost universally ignored by developers who mostly use CSS preprocessors). Keep nesting levels at a minimum. This is how CSS selectors rank according to their performance (starting from the fastest ones):<ul>
<li>Identificator: #id</li>
<li>Class: .class</li>
<li>Tag: div</li>
<li>Adjacent sibling selector: a + i</li>
<li>Parent selector: ul &gt; li</li>
<li>Universal selector: *</li>
<li>Attribute selector: input[type=”text”]</li>
<li>Pseudoclasses and pseudoelements: a:hover You should remember that browsers process selectors from right to left, that’s why the rightmost selector should be the fastest one — either #id or .class:<ul>
<li>div * {…} // bad</li>
<li>.list li {…} // bad</li>
<li>.list-item {…} // good</li>
<li>#list .list-item {…} // good</li>
</ul>
</li>
</ul>
</li>
<li>In your scripts, minimize DOM manipulation whenever possible. Cache everything, including properties and objects (if they are to be reused). It’s better to work with an “offline” element when performing complicated manipulations (an “offline” element is one that is disconnected from DOM and only stored in memory), and append it to DOM afterwards.</li>
<li>To change element’s styles, modifying the “class” attribute is one of the most performant ways. The deeper in the DOM tree you perform this change, the better (also because this helps decouple logic from presentation).</li>
<li>Animate only absolute/fixed positioned elements if you can.</li>
<li>It is a good idea to disable complicated :hover animations while scrolling (e.g. by adding an extra “no-hover” class to <body>).</body></li>
</ul>
</article></body></html>
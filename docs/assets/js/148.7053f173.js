(window.webpackJsonp=window.webpackJsonp||[]).push([[148],{465:function(t,s,a){"use strict";a.r(s);var e=a(33),n=Object(e.a)({},(function(){var t=this,s=t.$createElement,a=t._self._c||s;return a("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[a("h1",{attrs:{id:"typings"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#typings"}},[t._v("#")]),t._v(" typings")]),t._v(" "),a("p",[a("a",{attrs:{href:"https://en.wikipedia.org/wiki/Type_system",target:"_blank",rel:"noopener noreferrer"}},[t._v("Type System"),a("OutboundLink")],1)]),t._v(" "),a("p",[t._v('In programming languages, a type system is a set of rules that assigns a property called type to the various constructs of a computer program, such as variables, expressions, functions or modules.[1] These types formalize and enforce the otherwise implicit categories the programmer uses for algebraic data types, data structures, or other components (e.g. "string", "array of float", "function returning boolean").')]),t._v(" "),a("p",[t._v("The main purpose of a type system is to reduce possibilities for bugs in computer programs[2] by defining interfaces between different parts of a computer program, and then checking that the parts have been connected in a consistent way.")]),t._v(" "),a("p",[t._v("This checking can happen "),a("strong",[t._v("statically")]),t._v(" ("),a("strong",[t._v("at compile time")]),t._v("), "),a("strong",[t._v("dynamically")]),t._v(" ("),a("strong",[t._v("at run time")]),t._v("), or as a combination of static and dynamic checking.")]),t._v(" "),a("h2",{attrs:{id:"static-vs-dynamic-typings"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#static-vs-dynamic-typings"}},[t._v("#")]),t._v(" static vs dynamic typings")]),t._v(" "),a("h3",{attrs:{id:"static-type-checking"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#static-type-checking"}},[t._v("#")]),t._v(" static type checking")]),t._v(" "),a("p",[t._v("Static type checking is the process of verifying the type safety of a program based on analysis of a program's text (source code).\nIf a program passes a static type checker, then the program is guaranteed to satisfy some set of type safety properties for all possible inputs.")]),t._v(" "),a("p",[t._v("Can be ran before compile time, at write time.")]),t._v(" "),a("h3",{attrs:{id:"dynamic-type-checking"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#dynamic-type-checking"}},[t._v("#")]),t._v(" dynamic type checking")]),t._v(" "),a("p",[t._v("Dynamic type checking is the process of verifying the type safety of a program at runtime.")]),t._v(" "),a("h3",{attrs:{id:"combination"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#combination"}},[t._v("#")]),t._v(" combination")]),t._v(" "),a("p",[t._v("Combination of static and dynamic type checking enable downcasting :")]),t._v(" "),a("p",[t._v("In class-based programming, downcasting or type refinement is the act of casting a reference of a base class to one of its derived classes.")]),t._v(" "),a("p",[t._v("Example in Java :")]),t._v(" "),a("div",{staticClass:"language-java line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-java"}},[a("code",[t._v("\n"),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("public")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("class")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("Fruit")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("  "),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// parent class")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("public")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("class")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("Apple")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("extends")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("Fruit")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("  "),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// child class")]),t._v("\n\n"),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("public")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("static")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("void")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("main")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("String")]),t._v(" args"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n    "),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// The following is an implicit upcast:")]),t._v("\n    "),a("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("Fruit")]),t._v(" parent "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("new")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("Apple")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n    "),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// The following is a downcast. Here, it works since the variable `parent` is")]),t._v("\n    "),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// holding an instance of Apple:")]),t._v("\n    "),a("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("Apple")]),t._v(" child "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("Apple")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("parent"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n\n")])]),t._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[t._v("1")]),a("br"),a("span",{staticClass:"line-number"},[t._v("2")]),a("br"),a("span",{staticClass:"line-number"},[t._v("3")]),a("br"),a("span",{staticClass:"line-number"},[t._v("4")]),a("br"),a("span",{staticClass:"line-number"},[t._v("5")]),a("br"),a("span",{staticClass:"line-number"},[t._v("6")]),a("br"),a("span",{staticClass:"line-number"},[t._v("7")]),a("br"),a("span",{staticClass:"line-number"},[t._v("8")]),a("br"),a("span",{staticClass:"line-number"},[t._v("9")]),a("br"),a("span",{staticClass:"line-number"},[t._v("10")]),a("br"),a("span",{staticClass:"line-number"},[t._v("11")]),a("br"),a("span",{staticClass:"line-number"},[t._v("12")]),a("br")])]),a("h2",{attrs:{id:"manifest-vs-inferred-typings"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#manifest-vs-inferred-typings"}},[t._v("#")]),t._v(" manifest vs inferred typings")]),t._v(" "),a("h3",{attrs:{id:"manifest-typing"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#manifest-typing"}},[t._v("#")]),t._v(" manifest typing")]),t._v(" "),a("p",[t._v("Manifest typing is explicit identification by the software programmer of the type of each variable being declared.")]),t._v(" "),a("p",[t._v("For example: if variable X is going to store integers then its type must be declared as integer.")]),t._v(" "),a("div",{staticClass:"language-C line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-c"}},[a("code",[t._v("\n"),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("int")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("addone")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("int")]),t._v(" x"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n    "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("int")]),t._v(" result"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("/* declare integer result */")]),t._v("\n\n    result "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" x "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("+")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("1")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n    "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("return")]),t._v(" result"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n\n")])]),t._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[t._v("1")]),a("br"),a("span",{staticClass:"line-number"},[t._v("2")]),a("br"),a("span",{staticClass:"line-number"},[t._v("3")]),a("br"),a("span",{staticClass:"line-number"},[t._v("4")]),a("br"),a("span",{staticClass:"line-number"},[t._v("5")]),a("br"),a("span",{staticClass:"line-number"},[t._v("6")]),a("br"),a("span",{staticClass:"line-number"},[t._v("7")]),a("br"),a("span",{staticClass:"line-number"},[t._v("8")]),a("br")])]),a("p",[t._v("The type system rejects, at compile-time, such fallacies as trying to pass a string to "),a("code",[t._v("addone")]),t._v(" function.")]),t._v(" "),a("h3",{attrs:{id:"inferred-typing"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#inferred-typing"}},[t._v("#")]),t._v(" inferred typing")]),t._v(" "),a("p",[t._v("Type inference refers to the automatic detection of the data type of an expression in a programming language.")]),t._v(" "),a("p",[t._v("This JavaScript example would not work in C language :")]),t._v(" "),a("div",{staticClass:"language-javascript line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-javascript"}},[a("code",[t._v("\n"),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("function")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("addOneThenOne")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token parameter"}},[t._v("x")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n     "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("var")]),t._v(" result"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("  "),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("/* inferred-type variable result */")]),t._v("\n     "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("var")]),t._v(" result2"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("/* inferred-type variable result #2 */")]),t._v("\n\n     result "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" x "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("+")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("1")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n     result2 "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" result "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("+")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("1.0")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n\n     "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("return")]),t._v(" result2"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n\n "),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("addOneThenOne")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("2")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// return 4")]),t._v("\n\n")])]),t._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[t._v("1")]),a("br"),a("span",{staticClass:"line-number"},[t._v("2")]),a("br"),a("span",{staticClass:"line-number"},[t._v("3")]),a("br"),a("span",{staticClass:"line-number"},[t._v("4")]),a("br"),a("span",{staticClass:"line-number"},[t._v("5")]),a("br"),a("span",{staticClass:"line-number"},[t._v("6")]),a("br"),a("span",{staticClass:"line-number"},[t._v("7")]),a("br"),a("span",{staticClass:"line-number"},[t._v("8")]),a("br"),a("span",{staticClass:"line-number"},[t._v("9")]),a("br"),a("span",{staticClass:"line-number"},[t._v("10")]),a("br"),a("span",{staticClass:"line-number"},[t._v("11")]),a("br"),a("span",{staticClass:"line-number"},[t._v("12")]),a("br"),a("span",{staticClass:"line-number"},[t._v("13")]),a("br")])]),a("h2",{attrs:{id:"nominal-vs-structural-typings"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#nominal-vs-structural-typings"}},[t._v("#")]),t._v(" nominal vs structural typings")]),t._v(" "),a("h3",{attrs:{id:"nominal-typing"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#nominal-typing"}},[t._v("#")]),t._v(" nominal typing")]),t._v(" "),a("p",[t._v("A nominal or nominative type system (or name-based type system) is a major class of type system, in which compatibility and equivalence of data types is determined by explicit declarations and/or "),a("strong",[t._v("the name")]),t._v(" of the types.")]),t._v(" "),a("p",[t._v("Nominal typing means that two variables are type-compatible "),a("strong",[t._v("if and only if")]),t._v(" their declarations name the same type.")]),t._v(" "),a("p",[t._v("For example, in C, two "),a("code",[t._v("struct")]),t._v(" types with different names in the same translation unit are never considered compatible, even if they have identical field declarations.")]),t._v(" "),a("p",[t._v("C++, C#, Java, Objective-C, Delphi, Swift, and Rust all primarily use both nominal typing and nominal subtyping.")]),t._v(" "),a("h3",{attrs:{id:"structural-typing"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#structural-typing"}},[t._v("#")]),t._v(" structural typing")]),t._v(" "),a("p",[t._v("A structural type system (or property-based type system) is a major class of type system, in which type compatibility and equivalence are determined by the type's actual structure or definition, and not by other characteristics such as its name or place of declaration.")]),t._v(" "),a("h3",{attrs:{id:"pros-vs-cons"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#pros-vs-cons"}},[t._v("#")]),t._v(" pros vs cons")]),t._v(" "),a("p",[t._v("Nominal typing is useful at preventing accidental type equivalence, which allows better type-safety than structural typing. The cost is a reduced flexibility, as, for example, nominal typing does not allow new super-types to be created without modification of the existing subtypes.")]),t._v(" "),a("h2",{attrs:{id:"duck-typing"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#duck-typing"}},[t._v("#")]),t._v(" duck typing")]),t._v(" "),a("p",[t._v('"If it walks like a duck and it quacks like a duck, then it must be a duck."')]),t._v(" "),a("p",[t._v("Usually evaluated at runtime, some languages have capabilities to evaluate it at compile time.")]),t._v(" "),a("h3",{attrs:{id:"duck-typing-is-not-equal-to-structural-typing"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#duck-typing-is-not-equal-to-structural-typing"}},[t._v("#")]),t._v(" duck typing is not equal to structural typing")]),t._v(" "),a("p",[t._v("The main difference is that structural typing is enforced during static analysis found in statically typed languages, while duck typing is a runtime phenomenon emerging from the object semantics of dynamically typed languages.")]),t._v(" "),a("p",[t._v("In other wors, structural typing is a static typing and duck typing is a dynamic typing.")])])}),[],!1,null,null,null);s.default=n.exports}}]);
(window.webpackJsonp=window.webpackJsonp||[]).push([[148],{316:function(t,e,s){"use strict";s.r(e);var i=s(0),o=Object(i.a)({},(function(){var t=this,e=t._self._c;return e("div",{staticClass:"content"},[t._m(0),t._v(" "),e("p",[e("a",{attrs:{href:"https://medium.com/@koresar/fun-with-stamps-episode-1-stamp-basics-e0627d81efe0",target:"_blank",rel:"noopener noreferrer"}},[t._v("Fun with Stamps. Episode 1. Stamp basics"),e("OutboundLink")],1)]),t._v(" "),t._m(1),t._v(" "),e("p",[e("a",{attrs:{href:"https://github.com/stampit-org",target:"_blank",rel:"noopener noreferrer"}},[t._v("stampit-org"),e("OutboundLink")],1)]),t._v(" "),t._m(2),t._v(" "),e("p",[e("a",{attrs:{href:"https://github.com/ericelliott/rtype#rtype",target:"_blank",rel:"noopener noreferrer"}},[t._v("rtype"),e("OutboundLink")],1)]),t._v(" "),t._m(3),t._v(" "),e("p",[e("a",{attrs:{href:"https://github.com/stampit-org/stamp-specification",target:"_blank",rel:"noopener noreferrer"}},[t._v("stamp-specification : "),e("code",[t._v("github.com")]),e("OutboundLink")],1)]),t._v(" "),t._m(4),t._v(" "),e("p",[e("a",{attrs:{href:"https://github.com/stampit-org/stampit",target:"_blank",rel:"noopener noreferrer"}},[t._v("stampit impl"),e("OutboundLink")],1)]),t._v(" "),t._m(5),t._v(" "),e("p",[e("a",{attrs:{href:"https://github.com/stampit-org/stampit/blob/master/docs/API.md",target:"_blank",rel:"noopener noreferrer"}},[t._v("stampit API doc"),e("OutboundLink")],1)])])}),[function(){var t=this._self._c;return t("h1",{attrs:{id:"stamps"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#stamps"}},[this._v("#")]),this._v(" stamps")])},function(){var t=this,e=t._self._c;return e("ul",[e("li",[t._v("Episode 1. Stamp basics (this article)")]),t._v(" "),e("li",[t._v("Episode 2. Dependency injection in FP")]),t._v(" "),e("li",[t._v("Episode 3. Comparing with the ES2015 classes")]),t._v(" "),e("li",[t._v("Episode 4. Implementing stamps yourself in 30 LOC")]),t._v(" "),e("li",[t._v("Episode 5. Composition design pattern")]),t._v(" "),e("li",[t._v("Episode 6. Statics — properties on stamps")]),t._v(" "),e("li",[t._v("Episode 7. Early and late dependency injection")]),t._v(" "),e("li",[t._v("Episode 8. Tracking and overriding composition")]),t._v(" "),e("li",[t._v("Episode 9. Detaching compose()")]),t._v(" "),e("li",[t._v("Episode 10. My stamp mental model")]),t._v(" "),e("li",[t._v("Episode 11. Interfering composition")]),t._v(" "),e("li",[t._v("Episode 12. New @stamp home")]),t._v(" "),e("li",[t._v("Episode 13. Method collision control")]),t._v(" "),e("li",[t._v("Episode 14. New @stamp/it as a replacement of Stampit")]),t._v(" "),e("li",[t._v("Episode 15. The @stamp/ modules ecosystem")])])},function(){var t=this._self._c;return t("blockquote",[t("p",[t("strong",[this._v("Create objects from reusable, composable behaviors")])]),this._v(" "),t("p",[this._v("Stamps are standardised composable factory functions.")])])},function(){var t=this._self._c;return t("blockquote",[t("p",[this._v("Intuitive structural type notation for JavaScript.")]),this._v(" "),t("p",[this._v("Used to describe the API function signatures in specs")])])},function(){var t=this._self._c;return t("blockquote",[t("p",[this._v("define stamps format")])])},function(){var t=this._self._c;return t("blockquote",[t("p",[this._v("the current stampit-org impl (@3.2.1 the 20170916)")])])}],!1,null,null,null);e.default=o.exports}}]);
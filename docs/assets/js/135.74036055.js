(window.webpackJsonp=window.webpackJsonp||[]).push([[135],{458:function(e,t,o){"use strict";o.r(t);var a=o(33),i=Object(a.a)({},(function(){var e=this,t=e.$createElement,o=e._self._c||t;return o("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[o("h1",{attrs:{id:"code-complexity"}},[o("a",{staticClass:"header-anchor",attrs:{href:"#code-complexity"}},[e._v("#")]),e._v(" code complexity")]),e._v(" "),o("h2",{attrs:{id:"nombre-cyclomatique"}},[o("a",{staticClass:"header-anchor",attrs:{href:"#nombre-cyclomatique"}},[e._v("#")]),e._v(" Nombre cyclomatique")]),e._v(" "),o("p",[e._v("cf "),o("a",{attrs:{href:"https://fr.wikipedia.org/wiki/Nombre_cyclomatique",target:"_blank",rel:"noopener noreferrer"}},[e._v("d√©finition wikipedia"),o("OutboundLink")],1)]),e._v(" "),o("blockquote",[o("p",[e._v("Le nombre cyclomatique, la complexit√© cyclomatique ou la mesure de McCabe est un outil de m√©trologie logicielle d√©velopp√© par Thomas McCabe en 1976 pour mesurer la complexit√© d'un programme informatique. Cette mesure comptabilise le nombre de ¬´ chemins ¬ª au travers d'un programme repr√©sent√© sous la forme d'un graphe.")])]),e._v(" "),o("h2",{attrs:{id:"npath-complexity"}},[o("a",{staticClass:"header-anchor",attrs:{href:"#npath-complexity"}},[e._v("#")]),e._v(" NPath complexity")]),e._v(" "),o("p",[e._v("cf "),o("a",{attrs:{href:"http://www.developpez.net/forums/d961599/general-developpement/alm/usine-logicielle/qualimetrie/npath-complexity/#post7472939",target:"_blank",rel:"noopener noreferrer"}},[e._v("developpez.net"),o("OutboundLink")],1)]),e._v(" "),o("blockquote",[o("p",[e._v("La complexit√© NPath tente de r√©pondre √† la question ¬´ combien y-a-t-il de possibilit√©s de chemins diff√©rents ? ¬ª, en parcourant le code et en multipliant par le nombre de possibilit√©s √† l'entr√©e de chaque boucle (par exemple *2 pour un if, *7 pour un switch de 6 cas et un cas par d√©faut).")])]),e._v(" "),o("h2",{attrs:{id:"tldr-nombre-cyclomatique-vs-comlexite-npath"}},[o("a",{staticClass:"header-anchor",attrs:{href:"#tldr-nombre-cyclomatique-vs-comlexite-npath"}},[e._v("#")]),e._v(" TLDR nombre cyclomatique vs comlexit√© NPath")]),e._v(" "),o("ul",[o("li",[o("p",[e._v("la complexit√© cyclomatique compte le nombre de chemins sur la route")])]),e._v(" "),o("li",[o("p",[e._v("la complexit√© NPath le nombre total de possibilit√©s pour arriver du d√©but √† la fin de la route en empruntant ces chemins")])])]),e._v(" "),o("h2",{attrs:{id:"discussing-cyclomatic-complexity"}},[o("a",{staticClass:"header-anchor",attrs:{href:"#discussing-cyclomatic-complexity"}},[e._v("#")]),e._v(" Discussing Cyclomatic Complexity")]),e._v(" "),o("p",[e._v("cf "),o("a",{attrs:{href:"http://www.sonarqube.org/discussing-cyclomatic-complexity/",target:"_blank",rel:"noopener noreferrer"}},[e._v("page sonar"),o("OutboundLink")],1)]),e._v(" "),o("p",[e._v("Googling on Cyclomatic Complexity (CC), gives some interesting results‚Ä¶ Among those results, you‚Äôll find the two following definitions :")]),e._v(" "),o("ul",[o("li",[e._v("A measure of the complexity of a software module, equal to e ‚Äì n + 2, where e is the number of edges in the control flow graph and n is the number of nodes in this graph (that is, the cyclomatic number of the graph plus one)")]),e._v(" "),o("li",[e._v("A measurement of the intricacy of a program module based on the number of repetitive cycles or loops that are made in the program logic. It is used as a general measure of complexity for software quality control as well as to determine the number of testing procedures")]),e._v(" "),o("li",[e._v("‚Ä¶")])]),e._v(" "),o("p",[e._v("Those two definitions, though perfectly true, are one of the reason for Sonar to exist: going away from the fact that code source quality is a notion only accessible to elite. Sonar is about democratization of the source code quality concepts to be understandable and usable by every stakeholder in a development project.")]),e._v(" "),o("p",[e._v("Having said that, what is it that CC is trying to represent? This is roughly the number of different paths in your source code and there are two ways in java to begin a new path :")]),e._v(" "),o("ul",[o("li",[e._v("Calling a method (CC + 1)")]),e._v(" "),o("li",[e._v("Encountering the following keywords : if, while, repeat, for, &&, ||, catch, case, etc ‚Ä¶ (CC + 1)")])]),e._v(" "),o("p",[e._v("The good news is that calculating the cyclomatic complexity is a human accessible operation. Moreover, according to the previous definition it‚Äôs easy to understand that the more paths you have in your application, the more complex your application will be.")]),e._v(" "),o("p",[e._v("But does that mean a program with a high cyclomatic complexity has a poor quality ? For sure not ! Otherwise all developers would prevent themselves from doing anything beyond a simple ‚ÄúHelloWorld‚Äù program whose cyclomatic complexity is 1 and would quickly lose their jobs üòÉ")]),e._v(" "),o("p",[e._v("Having a high total cyclomatic complexity on a program just means that a lot of logic has been implemented in the program but you cannot deduce any quality information from there. When zooming on classes or methods, that‚Äôs another story.")]),e._v(" "),o("p",[e._v("Is it better to have a method with a CC of 30, or three methods with a CC of 10 each ? If you have been in charge of source code maintenance for an application written by somebody else, you know the answer : when having three methods with a CC of 10 each, the chance is higher that the program is more maintainable, with a better separation of logic. As a consequence, you also decrease the risk to inject a bug. The "),o("strong",[e._v("CC value by method can be used to evaluate the quality of the source code")]),e._v(".")]),e._v(" "),o("p",[e._v("At the class level, you can follow the same logic : high CC by class could be the witness of bad levels of decoupling, encapsulation and cohesion.")]),e._v(" "),o("p",[o("strong",[e._v("In fact, what matters in a program is not its total cyclomatic complexity but the fact that each of its methods / classes has a suitable low level of CC")]),e._v(".")]),e._v(" "),o("h2",{attrs:{id:"articles"}},[o("a",{staticClass:"header-anchor",attrs:{href:"#articles"}},[e._v("#")]),e._v(" Articles")]),e._v(" "),o("ul",[o("li",[o("p",[o("a",{attrs:{href:"https://modess.io/npath-complexity-cyclomatic-complexity-explained/",target:"_blank",rel:"noopener noreferrer"}},[e._v("NPath complexity and cyclomatic complexity explained : modess.io"),o("OutboundLink")],1)])]),e._v(" "),o("li",[o("p",[o("a",{attrs:{href:"http://www-igm.univ-mlv.fr/~dr/XPOSE2008/Mesure%20de%20la%20qualite%20du%20code%20source%20-%20Algorithmes%20et%20outils/complexite-cyclomatique.html",target:"_blank",rel:"noopener noreferrer"}},[e._v("Complexit√© cyclomatique : www-igm.univ-mlv.fr"),o("OutboundLink")],1)])])])])}),[],!1,null,null,null);t.default=i.exports}}]);